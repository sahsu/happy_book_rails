rails 性能優化心得

2012-05-11 18:46
分類： 技術
近期一個項目要上線（終於要交付了），交付前進行了一些大數據量下的性能優化，心得記錄下來：

1. 在開發的初期就要使用大量的數據。10K 比較合適。 有生產數據最好（比如需要跟其他系統進行交互），沒有的話，就自己生成（factory girl).   很多時候，打開一個性能糟糕的頁面，100條數據下看不出來什麼，但是10K數據下就看出速度來了。

2. 使用設計良好的MVC模式。該放在MODEL裏的，絕對不要放在CONTROLLER裏，更不要放在VIEW裏。原因是：
  2.1 耦合嚴重。我們要 decouple.
  2.2 很多性能測試工具，難以測試出頁面中的方法，但是可以測試出MODEL中的方法。
  2.3 放在MODEL中，容易寫單元測試（測試代碼易於編寫，那麼實現代碼就易於編寫）。

2. 另外，最好一次性的讀取數據，例如，你需要讀取3條記錄，最好使用這樣的方式：
  @device = Device.where("id in (1,2,3)")
  它會生成這樣形式的 SQL：    select .... where id in (1,2,3)

  而絕對不要在你的頁面中 ：

  [1,2,3].each { |i|  Device.where("id = #{i}") }

  因爲後者會鏈接數據庫 3 次， 而前者只一次。  想一想，如果你的某個循環需要重複鏈接數據庫1000次，該是什麼效果？  所以。...     回頭再詳述一下。(TODO)

3. WEBSERVICE 用的越少越好。 回頭專門詳述。 總之，這個是拖累系統速度的毒瘤。能不用就絕對不用，非用不可的話，一定要用緩存。

4. 緩存一定要用。可以不用MEMED CACHE這樣重量級的，但是起碼輕量級的一定要用。例如：
config.cache_store = :memory_store, {:expires_in => 60}
使用 observer與之配合，效果更好。

在上一個項目用，我用cache來緩存系統的常量。它們是可被配置的，保存在數據庫中，一般情況下不會被修改。 回頭我也寫個文章來記述一下。


5. 儘量少與其他 的系統交互。  這個也很拖累性能。（跟webservice 的理由一樣，一個response 需要2～4秒，客戶體驗不好）。 一定要加緩存。 例如，目前這個系統的“authorization" （授權），不是使用cancan或者 本地的數據庫表來授權，而是要訪問遠程的某個服務器，以GET方式讀取某個用戶的權限。
一般讀取一次需要1～2秒，如果某個頁面有5個地方需要授權，那麼打開這個頁面就要消耗10秒左右的時間。 所以，一定要做緩存。。。
TODO 同上面第四點，寫個專門的文章。。。

6. 使用SQLITE3的話，不要使用transaction. 可以使用delayed_job. 因爲一旦使用了TRANSACTION， 那麼很容易出現 鎖死的情況。用戶看到的就是 500 錯誤。 這個在生產環境下是不可接受的。 哪怕速度慢一點也沒關係，我們用一個沙漏啥的小動畫來告訴用戶，這個東西在後臺處理，需要等多少秒。用戶也就知道了：哦，它在正常工作，等一會兒我就可以繼續操作了。  （這個特別有效，比如說： 上傳100K個數據的 CSV， 對它進行驗證，讀取，驗證重複，導入的話，普通方式1000秒， 使用了transaction 300秒， 但是我們用delayed_job的話，用戶1秒後就可以看到響應結果（正常處理。。。啥的文字），就會體驗很好。 ）

7. 同六，凡是會讓用戶等待過久的地方，使用DELAYED——JOB。

8. 很多功能實現起來很容易，但是需要對某個功能進行進度控制，結果控制的話，就非常麻煩。例如：

  8.1 單純的導入100K個數據，非常容易。
  8.2 要求導入100K 個數據， 要求對某個屬性進行驗證，使之不能重複，也容易。
  8.3 在8.2的基礎上，還要求顯示結果，成功的有多少，失敗的有多少。這個就稍有些複雜了。你的代碼開始凌亂，有了壞味道，特別是單元測試不夠豐富的時候，原有的良好結構開始破壞。
  8.4 在8.3的基礎上，你使用了delayed_job，這個時候，要求用戶看到進度（比如30%）， 這個時候，你的代碼的複雜度，是8.1的10倍， 8.2的 5倍。 起碼在我目前這個項目中是這樣的。

9. 數據的冗餘很多情況下也是必要的。例如看這些功能：
  9.1 我們要調試100K個設備
  9.2 調試完畢後，記錄每個設備的調試信息。
  9.3 某天，我們刪除這些設備。
  9.4 管理員查看調試記錄，發現很多調試信息都丟失了。爲什麼？

  原來，系統的實現方式，是每個調試信息(debug_info) 對應於 設備(device)。那麼一旦 設備 被刪掉之後，那麼調試信息也就沒有了。這個是不被允許的。所以，比較理想的辦法，是在每個調試信息中，加上對應設備的信息。 雖然看起來比較冗餘，但是這是一種平衡。

  我們目前上線的系統中，幾乎每個模塊都有這樣的功能和需求。所以。。。哎。。。

10. 保持開發機器和生產環境的機器  環境要一致。這裏的一致包括：
  1. 操作系統。 哪怕一個是CENTOS 一個是 UBUNTU， 將就吧，但最好一模一樣
  2. 語言版本。 要麼都是RUBY 1.8.7，要麼都是 RUBY 1.9，要麼都是 RVM。
  3. 數據庫，  絕對不能一個是MYSQL， 一個是SQLITE3.
  4. 最好都能訪問一個網絡，不要出現一個處於內網一個處於外網，一個能訪問GIT一個不能，一個能訪問通過域名 ooxx.com 訪問 授權服務器，另一個則只能通過 ip 訪問。
  5. 最好VIM的版本都是一樣的。不能一個 7.3一個 6.9 ，一個有很多PLUGIN， 另一個沒有任何PLUGIN。
  6. 速度要一致。（生產環境的服務器的 SSH 速度不能太慢，例如不要一個在美國一個在大陸，否則 開發人員SSH 生產服務器之後，敲一下鍵盤3秒鐘之後纔看到結果，估計調試一個BUG要走神20次）

  以上幾點，任何一個不滿足都是有麻煩的。

11. 一定使用rails3 的 asset pipeline.
這個效果相當明顯。記得最初的項目，我們用了20個JS庫， 以及好多個CSS， 每次查看網絡通信的時候，發現由於每個JS，CSS，IMAGE都要讓客戶端/服務器重新發送一個 request/response，時間佔用的很多。使用了asset pipeline之後，性能改善太多，最顯著的就是：只有一個 JS， 一個 CSS 文件。而且RAILS3提供的文檔（優化 APACHE， NGINX ）也對緩存非常有效。現在圖片也緩存的非常好。 打個比方， 原來需要消耗10秒才能發送完畢CSS/JS/圖片，現在只需要2~5秒左右。太棒了。

12. 一定要使用coffee javascript. 這個不但提高開發效率，還提高執行效率，還能提供壓縮。 想起了 HIBERNATE  V。S。 RAW SQL。
